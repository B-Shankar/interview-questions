1. How does HashMap work internally after Java 8?
2. Why is HashMap not thread-safe even with final keys?
3. What happens internally when a HashMap reaches threshold capacity?
4. Difference between ConcurrentHashMap and Collections.synchronizedMap?
5. How does JVM decide memory allocation between Heap and Stack?
6. What causes OutOfMemoryError even when GC is running?
7. Explain Strong, Weak, Soft, and Phantom references with use cases.
8. Why String is immutable and how it improves performance?
9. Difference between ==, equals(), and hashCode() in real scenarios.
10. How does JVM handle class loading at runtime?

11. Explain ClassLoader hierarchy and when custom ClassLoader is needed.
12. What happens internally when you call new Thread().start()?
13. Why wait() and notify() are defined in Object class?
14. Difference between Runnable and Callable in concurrency?
15. What is the ForkJoinPool and when should you use it?
16. How does Java achieve thread safety without synchronization?
17. Explain happens-before relationship in Java Memory Model.
18. Why volatile does not guarantee atomicity?
19. Difference between optimistic and pessimistic locking.
20. What are memory leaks in Java? Can GC prevent them fully?

21. How does Stream API work internally?
22. Difference between parallelStream() and multithreading?
23. When should you avoid parallel streams?
24. How does Optional prevent NullPointerException?
25. What is method reference and how JVM resolves it?
26. Explain default methods in interfaces and their real use.
27. How does Java handle backward compatibility?
28. What happens if two threads deadlock — how JVM reacts?
29. Difference between fail-fast and fail-safe iterators.
30. How would you design a thread-safe LRU cache in Java?

These questions don’t test syntax.
They test how you THINK as a Java engineer.

If you can explain these confidently,
you’re already ahead of 90% candidates.